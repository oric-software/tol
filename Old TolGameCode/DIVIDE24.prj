
'if rom is out of the question, then....
'0500 MAP
'3500 BLOCKS
'4100 ZONES
'5D00 CHARACTER SET 0
'5F00 CHARACTER SET 1
'6100 CHARACTER SET 2
'6300 ANIMATIONS

'7000 SFX ETC
'8000 MC + TABLES (8K BYTES)
'A000 HIRES INLAY OF WHICH 1960 IS SPARE FOR MESSAGES
'AB40
'B500 STD CHARACTER SET
'B800
'B900 ALT CHARACTER SET
'BB81
'BCE8 SCREEN
'BFE0



'Y&A CORRUPTED
'00-03 USED

;LC_X_LO
;LC_X_HI
;LC_Y_LO
;LC_Y_HI
;LC_XL_OLD
;LC_XH_OLD
;LC_YL_OLD
;LC_YH_OLD
;LC_MAP_X
;LC_MAP_Y
;LC_ZONE_X
;LC_ZONE_Y
;LC_ZONE_OFFSET
;LC_BLOCK_X
;LC_BLOCK_Y
;LC_BLOCK_OFFSET
;HERO_XL
;HERO_XH
;HERO_YL
;HERO_YH

'MAP_BUFFER (MB)	HOLDS JUST THE MAP CHARS AND OBJECTS DROPPED (THIS IS SCROLLED)
'SCREEN_BUFFER (SB)	COPY MB INTO THIS, THEN PLOT PEOPLE & HERO
'REAL_SCREEN (RS)

:OBSTRUCT	'IDENTIFIES WHETHER A BYTE IS GROUND (0) OR AN IMPASSABLE OBJECT (>1)
[#00*$256]



&MOVE_LEFT	'SO SCROLL RIGHT & PLOT LEFT
	JSR &CHECK_OBS_LEFT
	BCS &MLF_04
	JSR &SCROLL_MB_RIGHT
	LDA ;HERO_XL
	SEC
	SBC #	'DISTANCE FROM L HERO TO L SCREEN -1
	STA ;LC_X_LO
	LDA ;HERO_XH
	SBC #00
	STA ;LC_X_HI
	LDA ;HERO_YL
	SBC #	'DISTANCE FROM T HERO TO T SCREEN
	STA ;LC_Y_LO
	LDA ;HERO_YH
	SBC #00
	STA ;LC_Y_HI
	LDA #	'TOP LEFT CORNER OF MB
	STA 10
	LDA #
	STA 11
	LDX #	'HEIGHT OF MB
&MLF_02	JSR &LOCATE_CHAR
	LDY #00
	STA (10),Y
	LDA		'SINCE WE'RE PLOTTING LEFT, WE NEED TO CAPTURE THE MEMORY CHAR FOR
	STA :CC_CHAR,X     	'COLOUR COLUMN, CC_CHAR 0 IS FOR BL SCREEN
	INC ;LC_Y_LO
	BNE &MLF_01
	INC ;LC_Y_HI
&MLF_01   LDA 10
	CLC
	ADC #	'WIDTH OF MB
	STA 10
	LDA 11
	ADC #00
	STA 11
	DEX
	BNE &MLF_02
	LDA ;HERO_XL	'NOW DECREMENT HEROS XPOS
	BNE &MLF_03
	DEC ;HERO_XH
&MLF_03	DEC ;HERO_XL
&MLF_04	RTS

&MOVE_RIGHT	'SO SCROLL MB LEFT AND PLOT RIGHT
	JSR &CHECK_OBS_RIGHT
	BCS &MRI_03
	JSR &SCROLL_MB_LEFT
	LDA ;HERO_XL
	CLC
	ADC #	'DISTANCE FROM L HERO TO R SCREEN +1
	STA ;LC_X_LO
	LDA ;HERO_XH
	ADC #00
	STA ;LC_X_HI
	LDA ;HERO_YL
	SEC
	SBC #	'DISTANCE FROM T HERO TO T SCREEN
	STA ;LC_Y_LO
	LDA ;HERO_YH
	SBC #00
	STA ;LC_Y_HI
	LDA #	'TOP RIGHT CORNER OF MB
	STA 10
	LDA #
	STA 11
	LDX #	'HEIGHT OF MB
&MRI_02	JSR &LOCATE_CHAR
	LDY #00
	STA (10),Y
	INC ;LC_Y_LO	'INCREMENT YPOS FOR EACH CHAR TO BE PLOTTED
	BNE &MRI_01
	INC ;LC_Y_HI
&MRI_01   LDA 10
	CLC
	ADC #	'WIDTH OF MB
	STA 10
	LDA 11
	ADC #00
	STA 11
	DEX
	BNE &MRI_02
	INC ;HERO_XL	'NOW DECREMENT HEROS XPOS
	BNE &MRI_03
	INC ;HERO_XH
&MRI_03	RTS

'THIS IS SLIGHTLY COMPLICATED BECAUSE WE MUST STORE COLOUR ASSOCIATED CHAR AT END OF TABLE.
&MOVE_UP	JSR &CHECK_OBS_UP
	BCS &MUP_04
	JSR &SCROLL_MB_DOWN	'SO SCROLL DOWN AND PLOT TOP
	LDA ;HERO_XL
	SEC
	SBC #	'DISTANCE FROM L HERO TO L SCREEN
	STA ;LC_X_LO
	LDA ;HERO_XH
	SBC #00
	STA ;LC_X_HI
	LDA ;HERO_YL
	SEC
	SBC #	'DISTANCE FROM T HERO TO T SCREEN
	STA ;LC_Y_LO
	LDA ;HERO_YH
	SBC #00
	STA ;LC_Y_HI
	LDA #	'TOP LEFT CORNER OF MB
	STA 10
	LDA #
	STA 11
	LDX #	'WIDTH OF MB
&MUP_02	JSR &LOCATE_CHAR
	LDY #00
	STA (10),Y
	INC ;LC_X_LO	'INCREMENT XPOS FOR EACH CHAR TO BE PLOTTED
	BNE &MUP_01
	INC ;LC_X_HI
&MUP_01   LDA 10
	CLC
	ADC #01
	STA 10
	LDA 11
	ADC #00
	STA 11
	DEX
	BNE &MUP_02
	LDA ;HERO_YL
	BNE &MUP_03
	DEC ;HERO_YH	'NOW DECREMENT HEROS YPOS
&MUP_03	DEC ;HERO_YL
&MUP_04	RTS

&MOVE_DOWN
	JSR &CHECK_OBS_DOWN
	BCS &MUP_03
	JSR &SCROLL_MB_UP
	LDA ;HERO_XL
	SEC
	SBC #	'DISTANCE FROM L HERO TO L SCREEN
	STA ;LC_X_LO
	LDA ;HERO_XH
	SBC #00
	STA ;LC_X_HI
	LDA ;HERO_YL
	CLC
	ADC #	'DISTANCE FROM T HERO TO B SCREEN
	STA ;LC_Y_LO
	LDA ;HERO_YH
	ADC #00
	STA ;LC_Y_HI
	LDA #	'BOTTOM LEFT CORNER OF MB
	STA 10
	LDA #
	STA 11
	LDX #	'WIDTH OF MB
&MUP_02	JSR &LOCATE_CHAR
	LDY #00
	STA (10),Y
	INC ;LC_X_LO	'INCREMENT XPOS FOR EACH CHAR TO BE PLOTTED
	BNE &MUP_01
	INC ;LC_X_HI
&MUP_01   LDA 10
	CLC
	ADC #01
	STA 10
	LDA 11
	ADC #00
	STA 11
	DEX
	BNE &MUP_02
	INC ;HERO_YL
	BNE &MUP_03
	INC ;HERO_YH	'NOW INCREMENT HEROS YPOS
&MUP_03	RTS

&CHECK_OBS_DOWN
	LDA ;HERO_XL
	STA ;LC_X_LO
	LDA ;HERO_XH
	STA ;LC_X_HI
	LDA ;HERO_YL
	CLC
	ADC #03	'DISTANCE FROM T HERO TO BELOW HERO
	STA ;LC_Y_LO
	LDA ;HERO_YH
	ADC #00
	STA ;LC_Y_HI
	JSR &LOCATE_BYTE
	TAX
	LDA :OBSTRUCT,X
	BEQ &COD_OK1
	SEC
	RTS
&COD_OK1	INC ;LC_X_LO
	BNE &COD_01
	INC ;LC_X_HI
&COD_01	JSR &LOCATE_BYTE
	TAX
	LDA :OBSTRUCT,X
	BEQ &COD_OK2
	SEC
	RTS
&COD_OK2	INC ;LC_X_LO
	BNE &COD_02
	INC ;LC_X_HI
	JSR &LOCATE_BYTE
	TAX
	CLC
	LDA :OBSTRUCT,X
	BEQ &COD_OK3
	SEC
&COD_OK3	RTS

&CHECK_OBS_UP
	LDA ;HERO_XL
	STA ;LC_X_LO
	LDA ;HERO_XH
	STA ;LC_X_HI
	LDA ;HERO_YL
	SEC
	SBC #01	'DISTANCE FROM T HERO TO BELOW HERO
	STA ;LC_Y_LO
	LDA ;HERO_YH
	SBC #00
	STA ;LC_Y_HI
	JSR &LOCATE_BYTE
	TAX
	LDA :OBSTRUCT,X
	BEQ &COU_OK1
	SEC
	RTS
&COU_OK1	INC ;LC_X_LO
	BNE &COU_01
	INC ;LC_X_HI
&COU_01	JSR &LOCATE_BYTE
	TAX
	LDA :OBSTRUCT,X
	BEQ &COU_OK2
	SEC
	RTS
&COU_OK2	INC ;LC_X_LO
	BNE &COU_02
	INC ;LC_X_HI
	JSR &LOCATE_BYTE
	TAX
	CLC
	LDA :OBSTRUCT,X
	BEQ &COU_OK3
	SEC
&COU_OK3	RTS

&CHECK_OBS_LEFT
	LDA ;HERO_YL
	STA ;LC_Y_LO
	LDA ;HERO_YH
	STA ;LC_Y_HI
	LDA ;HERO_XL
	SEC
	SBC #01	'DISTANCE FROM T HERO TO BELOW HERO
	STA ;LC_X_LO
	LDA ;HERO_YH
	SBC #00
	STA ;LC_X_HI
	JSR &LOCATE_BYTE
	TAX
	LDA :OBSTRUCT,X
	BEQ &COL_OK1
	SEC
	RTS
&COL_OK1	INC ;LC_Y_LO
	BNE &COL_01
	INC ;LC_Y_HI
&COL_01	JSR &LOCATE_BYTE
	TAX
	LDA :OBSTRUCT,X
	BEQ &COL_OK2
	SEC
	RTS
&COL_OK2	INC ;LC_Y_LO
	BNE &COL_02
	INC ;LC_Y_HI
	JSR &LOCATE_BYTE
	TAX
	CLC
	LDA :OBSTRUCT,X
	BEQ &COL_OK3
	SEC
&COL_OK3	RTS

&CHECK_OBS_RIGHT
	LDA ;HERO_YL
	STA ;LC_Y_LO
	LDA ;HERO_YH
	STA ;LC_Y_HI
	LDA ;HERO_XL
	CLC
	ADC #03	'DISTANCE FROM T HERO TO BELOW HERO
	STA ;LC_X_LO
	LDA ;HERO_XH
	ADC #00
	STA ;LC_X_HI
	JSR &LOCATE_BYTE
	TAX
	LDA :OBSTRUCT,X
	BEQ &COR_OK1
	SEC
	RTS
&COR_OK1	INC ;LC_Y_LO
	BNE &COR_01
	INC ;LC_Y_HI
&COR_01	JSR &LOCATE_BYTE
	TAX
	LDA :OBSTRUCT,X
	BEQ &COR_OK2
	SEC
	RTS
&COR_OK2	INC ;LC_Y_LO
	BNE &COR_02
	INC ;LC_Y_HI
	JSR &LOCATE_BYTE
	TAX
	CLC
	LDA :OBSTRUCT,X
	BEQ &COR_OK3
	SEC
&COR_OK3	RTS

&PLOT_PEOPLE
	LDA ;POS_FLAG
	BEQ &POS_01
	LDA ;HERO_XL
	SEC
	SBC #	'DISTANCE FROM L HERO TO L SCREEN
	STA ;LEFT_LIMIT_XL
	LDA ;HERO_XH
	SBC #00
	STA ;LEFT_LIMIT_XH
	LDA ;HERO_YL
	SBC #	'DISTANCE FROM T HERO TO T SCREEN
	STA ;TOP_LIMIT_YL
	LDA ;HERO_YH
	SBC #00
	STA ;TOP_LIMIT_YH
	LDA ;HERO_XL
	CLC
	ADC #	'DISTANCE FROM L HERO TO R SCREEN
	STA ;RIGHT_LIMIT_XL
	LDA ;HERO_XH
	ADC #00
	STA ;RIGHT_LIMIT_XH
	LDA ;HERO_YL
	ADC #	'DISTANCE FROM T HERO TO B SCREEN
	STA ;BOTTOM_LIMIT_YL
	LDA ;HERO_YH
	ADC #00
	STA ;BOTTOM_LIMIT_YH
	LDX ;LAST_PERSON
	???



'BLOCK=4*4 CHARS  (192 BLOCKS = 3072 BYTES)
'ZONE =8*8 BLOCKS (112 ZONES = 7168 BYTES)
'MAP  =128*96 ZONES (12288 BYTES)
'X & Y COORDINATES ARE FED IN AS FOLLOWS...
'LB_X_LO & LB_X_HI IS THE 16-BIT X COORDINATE (0-4095)
'LB_Y_LO & LB_Y_HI IS THE 16-BIT Y COORDINATE (0-3071) 12.5 MILLION LOCATIONS

&LOCATE_BYTE	'LOCATES CHARACTER
	LDA ;LB_X_LO
	STA 00
	AND #%00011100
	LSR
	LSR
	STA ;XPOS_IN_ZONE
	LDA ;LB_X_LO
	AND #03
	STA ;XPOS_IN_BLOCK
	LDA ;LB_X_HI
	LSR
	ROR 00
	LSR
	ROR 00
	LSR
	ROR 00
	LSR
	ROR 00
	LSR
	ROR 00
'	STA 01
	LDA ;LB_Y_LO
	AND #%11100000
	STA 02
	LDA ;LB_Y_LO
	AND #%00011100
	ASL
	ORA ;XPOS_IN_ZONE
	STA ;OFFSET_IN_ZONE
	LDA ;LB_Y_LO
	AND #03
	ASL
	ASL
	ORA ;XPOS_IN_BLOCK
	STA ;OFFSET_IN_BLOCK
	LDA ;LB_Y_HI
	ASL 02
	ROL
	ASL 02
	ROL
	ORA #C0
	STA 01
	LDA 02
	ORA 00
	STA 00
	LDY #00
	LDA (00),Y	'ZONE NUMBER
	STY 01
	ASL
	ASL
	ROL 01
	ASL
	ROL 01
	ASL
	ROL 01
	ASL
	ROL 01
	ASL
	ROL 01
	ORA ;OFFSET_IN_ZONE
	ADC #		'ZONE START L
	STA 00
	LDA 01
	ADC #               'ZONE START H
	STA 01
	LDA (00),Y	'BLOCK NUMBER
	STY 01
	ASL
	ROL 01
	ASL
	ROL 01
	ASL
	ROL 01
	ASL
	ROL 01
	ORA ;OFFSET_IN_BLOCK
	ADC #		'BLOCK START L
	STA 00
	LDA 01
	ADC #               'BLOCK START H
	STA 01
	LDA (00),Y	'THAT'S IT!!















	LDY ;LC_X_HI		'WORK OUT FOR X-POSITION
	LDA ;LC_X_LO
	CPY ;LC_XH_OLD
	BNE &DIV_09
	CMP ;LC_XL_OLD
	BEQ &DIV_08	'OPTIMISE WHERE POSSIBLE
	STY 01
	LDY #FF
	SEC
&DIV_01	INY
	SBC #$24
	BCS &DIV_01
	SEC
	DEC 01
	BPL &DIV_01
	ADC #$23
	STY ;LC_MAP_X  	'MAP OFS X
	LDY #FF
	SEC
&DIV_02	INY
	SBC #$06
	BCS &DIV_02
	STY ;LC_ZONE_X 	'ZONE OFS X
	ADC #$06
	STA ;LC_BLOCK_X	'BLOCK OFS X

&DIV_08   LDY ;LC_Y_HI
	LDA ;LC_Y_LO
	CPY ;LC_YH_OLD
	BNE &DIV_10
	CMP ;LC_YL_OLD
	BEQ &DIV_09	'OPTIMISE WHERE POSSIBLE
&DIV_10	STY 01
	LDY #FF
	SEC
&DIV_03	INY
	SBC #$20
	BCS &DIV_03
	SEC
	DEC 01
	BPL &DIV_01
	ADC #$19
	STY ;LC_MAP_Y	'MAP OFS Y
	LDY #FF
	SEC
&DIV_04	INY
	SBC #$05
	BCS &DIV_04
	STY ;LC_ZONE_Y	'ZONE OFS Y
	ADC #$05
	STA ;LC_BLOCK_Y
&DIV_09	LDA ;LC_BLOCK_Y
	ASL                 'X4 (WIDTH OF BLOCK)
	ASL
	ADC ;LC_BLOCK_X
	STA ;LC_BLOCK_OFFSET		'BLOCK OFS!!
	LDA ;LC_ZONE_Y	'X6 (ZONE WIDTH)
	ASL
	STA ;LC_TEMP_01
	ASL
	ADC ;LC_TEMP_01
	ADC ;LC_ZONE_X
	STA ;LC_ZONE_OFFSET
	LDA #00
	STA 01
	STA 02		'CHAR BASE LO
	LDY ;LC_MAP_Y	'X128 (MAP WIDTH)
	ASL
	ASL
	ROL 01
	ASL
	ROL 01
	ASL
	ROL 01
	ASL
	ROL 01
	ASL
	ROL 01
	ASL
	ROL 01
	ADC #00		'MAP_BASE_LO
	STA 00
	LDA 01
	ADC #C0		'MAP_BASE_HI
	STA 01
	LDY ;LC_MAP_X
	LDA (00),Y	'GOT THE ZONE NUMBER
	TAY
	LDA :ZONE_LOC_LO,Y
	STA 00
	LDA :ZONE_LOC_HI,Y
	STA 01
	LDY ;LC_ZONE_OFFSET
	LDA (00),Y	'GOT THE BLOCK NUMBER
	TAY
	LDA :BLOCK_LOC_LO,Y
	STA 00
	LDA :BLOCK_LOC_HI,Y
	STA 01
	LDY ;LC_BLOCK_OFFSET
	LDA (00),Y	'THIS MUST BE THE CHARACTER!!!
	RTS

&LOCATE_CHAR
	JSR &LOCATE_BYTE
	CMP #20		'IS IT AN ATTRIBUTE?
	BCC &DIV_06
	TAY
	SBC #20		'FIND DEFINITIVE CHARACTER (32-95)
	AND #3F
	STA ;LC_TEMP_02
	ADC #1F		'(CARRY WILL HAVE BEEN SET BY PREVIOUS SBC)
	CPY #$224		'CHARACTERS OVER 223 ARE INVERSED
	BCC &DIV_07
	ORA #80
&DIV_07	PHA			'PUSH CHARACTER TO STORE ONTO STACK FOR END
	LDA ATTRIBUTE_ASSOCIATION,Y	'FETCH AFFILIATED BANK
	ASL			'B6-7 HOLDS BANK, B0-5 HOLDS INK AND PAPER
	ROL
	ROL
	AND #03
	CMP :CURRENT_BANK,Y		'CURRENT BANK?
	BEQ &GOT_BANK
	ASL			'SO NEED TO REDEFINE
	PHA
	LDA ;LC_TEMP_02
	ASL         		'MULTIPLY BY 8 (X8)
	ASL
	ASL
	STA 00
	PLA
	ADC #30			'BASE_CHAR_MEMORY_HI
	STA 01
	AND #01                       'GET CARRY AGAIN
	ADC #B5                       'ADD CHARACTER MEMORY BASE
	STA 03
	LDY #07			'COPY IT
&DIV_05	LDA (00),Y
	STA (02),Y
	DEY
	BPL &DIV_05
&GOT_BANK	PLA			'A=CHARACTER TO STORE
&DIV_06	RTS















	RTS

'fabrices amendments

Jonathan wrote in message <9iigh4$o8m$1@news5.svr.pol.co.uk>...
>
>OK, for Times of Lore, i have this routine to calculate a character at a
>given X/Y position in the big map. Can anyone improve on it (Speed it up) ?


Yeap, but before speeding it up, you should correct a few errors
and bugs :
after dividing X by 24 (which is the width of a zone), you must divide
by 4 (which is the width of a block), not by 6.
Same thing after dividing by 20 (height of a zone), you must divide
by 4 (height of a block), not by 5.

>LOCATE_CHAR
> LDY LC_X_HI  ;WORK OUT FOR X-POSITION
> LDA LC_X_LO
> CPY LC_XH_OLD
> BNE DIV_09

instead use a BNE DIV_00

> CMP LC_XL_OLD
> BEQ DIV_08 ;OPTIMISE WHERE POSSIBLE

with label DIV_00 here
DIV_00

> STY $01
> LDY #$FF
> SEC
> DIV_01 INY
> SBC #24
> BCS DIV_01
> SEC
> DEC $01
> BPL DIV_01
> ADC #23
> STY LC_MAP_X   ;MAP OFS X

we will see how to speed this division by 24 later...

> LDY #$FF
> SEC
>DIV_02  INY
> SBC #06
> BCS DIV_02
> STY LC_ZONE_X  ;ZONE OFS X
> ADC #06
> STA LC_BLOCK_X ;BLOCK OFS X

replacing this fragment with a divide by 4:

TAY
LSR
LSR
STA LC_ZONE_X
TYA
AND #3
STA LC_BLOCK_X

>DIV_08    LDY LC_Y_HI
> LDA LC_Y_LO
> CPY LC_YH_OLD
> BNE DIV_10
> CMP LC_YL_OLD
> BEQ DIV_09 ;OPTIMISE WHERE POSSIBLE
>DIV_10  STY $01
> LDY #$FF
> SEC
>DIV_03  INY
> SBC #20
> BCS DIV_03
> SEC
> DEC $01
> BPL DIV_01
> ADC #19
> STY LC_MAP_Y ;MAP OFS Y

will see division by 20 later...

> LDY #$FF
> SEC
>DIV_04  INY
> SBC #05
> BCS DIV_04
> STY LC_ZONE_Y ;ZONE OFS Y
> ADC #05
> STA LC_BLOCK_Y

replacing the above fragment with a divide by 4:
TAY
LSR
LSR
STA LC_ZONE_Y
TYA
AND #3
STA LC_BLOCK_Y

and no problem with the rest of the routine.
So, you need faster divide-by-24 and divide-by-20
code fragments (ahem... anything would be faster
than a substract loop ;-)
Didn't I write one last time ?
Ah, maybe I only wrote a routine giving the quotient,
not the rest ? Let me check...

CU in next post,

Fabrice

next one.........

>Yeap, but before speeding it up, you should correct a few errors

Oops, I have found my old mail and it seems you have followed the
formulas I gave you, and they were wrong (divisions by 5 and 6 instead
of divisions by 4)
:-P

So, about the division by 24, there's a few instructions to add to
what I wrote, in order to have the rest of the division too:

    sta tmp    ; A is LC_X_LO in your code
    tya            ; and Y is LC_X_HI
    lsr
    ror tmp
    lsr
    ror tmp
    lsr
    ror tmp
    ldx tmp
    lsr
    bcs hi_table
    ldy table3,x
    lda rest3,x
    bcc adjusting_the_rest
hi_table:
    ldy table3+256,x
    lda rest3+256,x
adjusting_the_rest:
    sty LC_ZONE_X
    asl
    asl
    asl
    sta tmp
    lda LC_X_LO
    and #7
    ora tmp
    sta LC_BLOCK_X

with two 384-bytes-length tables:
table3 db 0,0,0,1,1,1,2,2,2,3,3,3.....,127,127,127
rest3 db 0,1,2,0,1,2,0,1,2,0,1,2....,0,1,2

Et voilà ! About 65 cycles for this fragment, versus an
average of 500 cycles for the substract loop...

It's about the same thing for the divide by 20, of course
(first shifting two times in order to divide by 4, and then
using two 480-bytes-length tables:
table5 db 0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,...,95,95,95,95,95
rest5 db 0,1,2,3,4,0,1,2,3,4.....,0,1,2,3,4
)

Mhhh... didn't we have an old thread in this newsgroup
about another fast way to divide by 3 ?

Cheers,

Fabrice




~END
